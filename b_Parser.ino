void printHex(uint8_t d, boolean upper)
{
  char t;
  char a = upper ? 'A' : 'a';
  t = d >> 4 | '0';
  if (t > '9') {
    t += a - '9' - 1;
  }
  DEBUG_print(t);
  t = d & 0xF | '0';
  if (t > '9') {
    t += a - '9' - 1;
  }
  DEBUG_print(t);
}

void _printOutPut()
{
  int buflen = buf[0];
  DEBUG_print(F("> "));
  for (int i = 4; i <= buflen; i++) {
    if ((i == 4 || i == 5) && isprint(buf[i])) {
      DEBUG_print(' '); DEBUG_print((char) buf[i]);
    } else {
      printHex(buf[i], false);
    }
    DEBUG_print(' ');
  }
  DEBUG_println("");
}

// parse command that is broadcasted to cameras
void parseSerialWrite()
{
  _printOutPut();
  switch (buf[2]) {
    case 2: // two letter commands
      switch ((buf[4] << 8) + buf[5]) {
        case ('Y' << 8) + 'Y':
          YYcommand();
          break;
        case ('Z' << 8) + 'Z':
          ZZcommand();
          break;
      }
      break;
  }
}

void YYcommand()
{
  switch (buf[8]) {
    default:
      extendedYYcommand();
      break;
  }
}

int ZZcommand()
{
  switch (buf[8]) {
    case 1:
      switch (buf[9]) {
        case 0:
          // Dual Hero only
          break;
      }
      break;
    case 2: // power on/off by long button press at primary camera
      switch (buf[9]) {
        case 0: // power off
          break;
        case 1: // power on
          break;
      }
      break;
    case 3: // get camera version
      break;
    case 0: // extended command
      extendedZZcommand(); 
      break;
  }
}

int extendedYYcommand()
{
  char sub;
  switch (buf[9]) {
    case 1: // mode change
      switch (buf[10]) {
        case 1: // set main mode
          setting.p.mode = buf[13];
          break;
        case 5: // set main and sub modes
          setting.p.mode = buf[13];
          setting.p.current_submode[setting.p.mode] = buf[14];
          break;
      }
      break;
    case 2: // video
      sub = setting.p.current_submode[MODE_VIDEO];
      switch (buf[10]) {
        case 1: // default sub mode
          storeDefaultSubMode(MODE_VIDEO, buf[13]);
          break;
        case 3: // argc = 3: resolution, fps, fov
          storage[sub].p.video.resolution = buf[13];
          storage[sub].p.video.fps = buf[14];
          storage[sub].p.video.fov = buf[15];
          break;
        case 5: // piv. Note: not generated by ID_MASTER (default firmware's bug)
          storage[sub].p.video.piv = buf[13];
          break;
        case 7: // looping
          storage[sub].p.video.looping = buf[13];
          break;
        case 9: // low_light. Note: not generated by ID_MASTER (default firmware's bug)
          storage[sub].p.video.low_light = buf[13];
          break;
        case 11: // spot meter
          storage[sub].p.video.spot_meter = buf[13];
          break;
        case 13: // timelapse_rate
          storage[sub].p.video.timelapse_rate = buf[13];
          break;
        case 15: // protune
          storage[sub].p.video.protune = buf[13];
          break;
        case 17: // protune_white_balance
          storage[sub].p.video.protune_white_balance = buf[13];
          break;
        case 19: // protune_color
          storage[sub].p.video.protune_color = buf[13];
          break;
        case 21: // protune_sharpness
          storage[sub].p.video.protune_sharpness = buf[13];
          break;
        case 23: // protune_iso
          storage[sub].p.video.protune_iso = buf[13];
          break;
        case 25: // protune_ev
          storage[sub].p.video.protune_ev = buf[13];
          break;
        case 26: // reset protune. argc = 0
          break;
        case 27: // shutter button depressed. start
          recording_state = STATE_START;
          break;
        case 28: // sync stop
          recording_state = STATE_STOP;
          break;
        case 38: // all video settings
          for (int i = 0; i < 4; i++) {
            storage[i].p.video.default_sub_mode      = buf[14 + i * 24];
            storage[i].p.video.resolution            = buf[15 + i * 24];
            storage[i].p.video.fps                   = buf[16 + i * 24];
            storage[i].p.video.fov                   = buf[17 + i * 24];
            storage[i].p.video.piv                   = buf[18 + i * 24];
            storage[i].p.video.looping               = buf[19 + i * 24];
            storage[i].p.video.spot_meter            = buf[20 + i * 24];
            storage[i].p.video.low_light             = buf[21 + i * 24];
            storage[i].p.video.timelapse_rate        = buf[22 + i * 24];
            storage[i].p.video.protune               = buf[23 + i * 24];
            storage[i].p.video.protune_color         = buf[24 + i * 24];
            storage[i].p.video.protune_sharpness     = buf[25 + i * 24];
            storage[i].p.video.protune_iso           = buf[26 + i * 24];
            storage[i].p.video.protune_ev            = buf[27 + i * 24];
            storage[i].p.video.protune_white_balance = buf[28 + i * 24];
            storage[i].p.v4.videoExposure_time       = buf[29 + i * 24];
            storage[i].p.v4.videoProtune_iso_mode    = buf[30 + i * 24];
          }
          break;
        case 40: // exposure_time
          storage[sub].p.v4.videoExposure_time = buf[13];
          break;
        case 42: // protune_iso_mode
          storage[sub].p.v4.videoProtune_iso_mode = buf[13];
          break;
      }
      break;
    case 3: // photo
      sub = setting.p.current_submode[MODE_PHOTO];
      switch (buf[10]) {
        case 1: // default sub mode
          storeDefaultSubMode(MODE_PHOTO, buf[13]);
          break;
        case 3: // resolution
          storage[sub].p.photo.resolution = buf[13];
          break;
        case 5: // continuous_rate
          storage[sub].p.photo.continuous_rate = buf[13];
          break;
        case 7: // spot meter
          storage[sub].p.photo.spot_meter = buf[13];
          break;
        case 9: // exposure_time
          storage[sub].p.photo.exposure_time = buf[13];
          break;
        case 11: // protune
          storage[sub].p.photo.protune = buf[13];
          break; 
        case 13: // protune_white_balance
          storage[sub].p.photo.protune_white_balance = buf[13];
          break;
        case 15: // protune_color
          storage[sub].p.photo.protune_color = buf[13];
          break;
        case 17: // protune_sharpness
          storage[sub].p.photo.protune_sharpness = buf[13];
          break;
        case 19: // protune_iso
          storage[sub].p.photo.protune_iso = buf[13];
          break;
        case 21: // protune_ev
          storage[sub].p.photo.protune_ev = buf[13];
          break;
        case 22: // reset protune. argc = 0
          break;
        case 23: // shutter button depressed. start
          recording_state = STATE_START;
          break;
        case 24: // stop (continuous sub mode only)
          recording_state = STATE_STOP;
          break;
        case 27: // all photo settings
          for (int i = 0; i < 3; i++) {
            storage[i].p.photo.default_sub_mode      = buf[14 + i * 20];
            storage[i].p.photo.resolution            = buf[15 + i * 20];
            storage[i].p.photo.continuous_rate       = buf[16 + i * 20];
            storage[i].p.photo.spot_meter            = buf[17 + i * 20];
            storage[i].p.photo.exposure_time         = buf[18 + i * 20];
            storage[i].p.photo.protune               = buf[19 + i * 20];
            storage[i].p.photo.protune_color         = buf[20 + i * 20];
            storage[i].p.photo.protune_sharpness     = buf[21 + i * 20];
            storage[i].p.photo.protune_iso           = buf[22 + i * 20];
            storage[i].p.photo.protune_ev            = buf[23 + i * 20];
            storage[i].p.photo.protune_white_balance = buf[24 + i * 20];
            storage[i].p.v4.photoProtune_iso_min     = buf[25 + i * 20];
          }
          break;
        case 29: // protune_iso_min
          storage[sub].p.v4.photoProtune_iso_min = buf[13];
          break;
      }
      break;
    case 4: // multi-shot
      sub = setting.p.current_submode[MODE_MULTI_SHOT];
      switch (buf[10]) {
        case 1: // default sub mode
          storeDefaultSubMode(MODE_MULTI_SHOT, buf[13]);
          break;
        case 3: // resolution
          storage[sub].p.multi_shot.resolution = buf[13];
          break;
        case 5: // burst_rate
          storage[sub].p.multi_shot.burst_rate = buf[13];
          break;
        case 7: // timelapse_rate
          storage[sub].p.multi_shot.timelapse_rate = buf[13];
          break;
        case 9: // nightlapse_rate
          storage[sub].p.multi_shot.nightlapse_rate = buf[13];
          break;
        case 11: // spot_meter
          storage[sub].p.multi_shot.spot_meter = buf[13];
          break;
        case 13: // exposure_time
          storage[sub].p.multi_shot.exposure_time = buf[13];
          break;
        case 15: // protune
          storage[sub].p.multi_shot.protune = buf[13];
          break;
        case 17: // protune_white_balance
          storage[sub].p.multi_shot.protune_white_balance = buf[13];
          break;
        case 19: // protune_color
          storage[sub].p.multi_shot.protune_color = buf[13];
          break;
        case 21: // protune_sharpness
          storage[sub].p.multi_shot.protune_sharpness = buf[13];
          break;
        case 23: // protune_iso
          storage[sub].p.multi_shot.protune_iso = buf[13];
          break;
        case 25: // protune_ev
          storage[sub].p.multi_shot.protune_ev = buf[13];
          break;
        case 26: // reset protune. arg = 0
          break;
        case 27: // shutter button depressed. start
          recording_state = STATE_START;
          break;
        case 28: // stop
          recording_state = STATE_STOP;
          break;
        case 32: // bulk transfer multi-shot settings
          for (int i = 0; i < 3; i++) {
            storage[i].p.multi_shot.default_sub_mode      = buf[14 + i * 22];
            storage[i].p.multi_shot.resolution            = buf[15 + i * 22];
            storage[i].p.multi_shot.burst_rate            = buf[16 + i * 22];
            storage[i].p.multi_shot.timelapse_rate        = buf[17 + i * 22];
            storage[i].p.multi_shot.nightlapse_rate       = buf[18 + i * 22];
            storage[i].p.multi_shot.spot_meter            = buf[19 + i * 22];
            storage[i].p.multi_shot.exposure_time         = buf[20 + i * 22];
            storage[i].p.multi_shot.protune               = buf[21 + i * 22];
            storage[i].p.multi_shot.protune_color         = buf[22 + i * 22];
            storage[i].p.multi_shot.protune_sharpness     = buf[23 + i * 22];
            storage[i].p.multi_shot.protune_iso           = buf[24 + i * 22];
            storage[i].p.multi_shot.protune_ev            = buf[25 + i * 22];
            storage[i].p.multi_shot.protune_white_balance = buf[26 + i * 22];
            storage[i].p.v4.multi_shotProtune_iso_min     = buf[27 + i * 22];
          }
          break;
        case 34: // protune_iso_min (v4)
          storage[sub].p.v4.multi_shotProtune_iso_min = buf[13];
          break;
      }
      break;
    case 7: // global settings
      switch (buf[10]) {
        case 1: // LCD brightness
          setting.p.setup.lcd_brightness = buf[13];
          break;
        case 3: // LCD sleep
          setting.p.setup.lcd_sleep = buf[13];
          break;
        case 5: // LCD lock
          setting.p.setup.lcd_lock = buf[13];
          break;
        case 7: // LCD power
          setting.p.lcd = buf[13];
          break;
        case 9: // orientation
          // orientation can be set only by using this command.
          // there's a orientation byte in bulk setting transfer but it will be ignored. (default firmware's bug)
          setting.p.setup.orientation = buf[13];
          break;
        case 11: // default mode
          setting.p.setup.default_app_mode = buf[13];
          break;
        case 13: // quick capture
          setting.p.setup.quick_capture = buf[13];
          break;
        case 15: // LEDs
          setting.p.setup.led = buf[13];
          break;
        case 17: // beeps
          setting.p.setup.beep_volume = buf[13];
          break;
        case 19: // video format
          setting.p.setup.video_format = buf[13];
          break;
        case 21: // OSD
          setting.p.setup.osd = buf[13];
          break;
        case 23: // auto power down
          setting.p.setup.auto_power_down = buf[13];
          break;
        case 27: // date/time (Note: a word data is stored as big-endian)
          // buf[11:12]        buf[13:14] buf[15] buf[16] buf[17] buf[18] buf[19]
          // arglen = 7  args: year       month   day     hour    minute  second
#ifdef USE_RTC
          rtc.adjust(DateTime((int)(buf[13] * 256 + buf[14]), buf[15], buf[16], buf[17], buf[18], buf[19]));
#else
          {
            TimeElements tE;
            tE.Year = buf[13] * 256 + buf[14] - 1970; tE.Month = buf[15]; tE.Day = buf[16];
            tE.Hour = buf[17]; tE.Minute = buf[18]; tE.Second = buf[19];
            setTime(makeTime(tE));
          }
#endif /* USE_RTC */
          break;
        case 32: // language
          break;
        case 33: // bulk transfer global settings
          setting.p.setup.osd = buf[19];
          setting.p.setup.beep_volume = buf[20];
          setting.p.setup.auto_power_down = buf[21];
          setting.p.setup.led = buf[22];
          setting.p.setup.quick_capture = buf[23];
          setting.p.setup.orientation = buf[24]; // this byte is ignored by camera (default firmware's bug)
          setting.p.setup.lcd_brightness = buf[25];
          setting.p.setup.lcd_sleep = buf[26];
          setting.p.setup.lcd_lock = buf[27];
          setting.p.lcd = buf[28];
          setting.p.setup.video_format = buf[29];
          // buf[30]; // 0: English, 1: Simplified Chinese
          // buf[31:37] // reserved
          // buf[38]; // const 1; unknown
          setting.p.setup.default_app_mode = buf[39];
          storeDefaultSubMode(setting.p.setup.default_app_mode, buf[40]);
#ifdef USE_RTC
          rtc.adjust(DateTime((int)(buf[41] * 256 + buf[42]), buf[43], buf[44], buf[45], buf[46], buf[47]));
#else
          {
            TimeElements tE;
            tE.Year = buf[41] * 256 + buf[42] - 1970; tE.Month = buf[43]; tE.Day = buf[44];
            tE.Hour = buf[45]; tE.Minute = buf[46]; tE.Second = buf[47];
            setTime(makeTime(tE));
          }
#endif /* USE_RTC */      
          break;
      }
      break;
    case 9: // delete
      switch (buf[10]) {
        case 9: // delete last
          break;
        case 10: // delete all/format
          break;
      }
      break;
  }
  loadSetupValue();
}

void extendedZZcommand()
{
  switch (buf[9]) {
    case 0: // init external sync
      // use external sync 1 0 *
      break;
    case 1: // sync
      switch (buf[10]) {
        case 1: // status request
          switch (buf[11]) {
            case 0:
              break;
            case 1:
              break;
          }
          break;
        case 2: // block until writing to microSD complete
          break;
      }
      break;
    case 2: // Heartbeat
      break;
    case 3: // power off
      disp_state = MENU_START;
      ROM_write(); // store settings to EEPROM
      // software reset within 1s
      wdt_enable(WDTO_1S);
      while (1); // loop forever
      // never reach here
      break;
    case 5: // bacpac firmware version
      break;
    case 6: // bacpac serial number
      break;
  }
}
